#!/usr/bin/env ruby

require 'bundler/setup'
require 'optparse'
require_relative '../lib/annicter'

def parse_options
  options = {}

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: annicter [options]"
    opts.separator ""
    opts.separator "Options:"

    opts.on("-s", "--season SEASON", "Specify season in YYYY-SEASON format (e.g., 2025-summer, 2024-winter)") do |season|
      options[:season] = season
    end

    opts.on("--simple", "Output only titles in newline-separated format") do
      options[:simple] = true
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit 0
    end
  end

  parser.parse!
  options
end

def main
  options = parse_options

  access_token = ENV['ANNICT_ACCESS_TOKEN']

  if access_token.nil? || access_token.empty?
    puts "Error: ANNICT_ACCESS_TOKEN environment variable is not set."
    puts "Please set your Annict API access token in the .env file or as an environment variable."
    puts "You can get your token from: https://annict.com/settings/apps"
    exit 1
  end

  # Validate season format if provided
  if options[:season] && !Annicter::Season.valid?(options[:season])
    puts "Error: Invalid season format: #{options[:season]}"
    puts "Season must be in YYYY-SEASON format (e.g., 2025-summer, 2024-winter)"
    puts "Valid seasons: winter, spring, summer, autumn"
    exit 1
  end

  begin
    client = Annicter::Client.new(access_token)

    # Test connection
    unless client.test_connection
      puts "Error: Invalid access token or unable to connect to Annict API."
      exit 1
    end

    season = options[:season] || Annicter::Season.current
    works = client.watched_works(season)

    if options[:simple]
      # Simple mode: output only titles, one per line
      works.each do |work|
        puts work.title
      end
    else
      # Normal mode: Scrapbox format
      works.each_with_index do |work, index|
        puts "[* #{work.title}]"
        puts "\n" if index < works.size - 1
      end
    end

  rescue Annicter::Error => e
    puts "Error: #{e.message}"
    exit 1
  rescue StandardError => e
    puts "Unexpected error: #{e.message}"
    puts e.backtrace if ENV['DEBUG']
    exit 1
  end
end

main if __FILE__ == $0